<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ver 5.2.2</title>
    <style>
        body { margin: 0; padding: 0; background-color: #0f172a; overflow: hidden; touch-action: none; }
        #gameCanvas { display: block; }
        .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; color: white; font-family: sans-serif; }
        .st-info { position: absolute; top: 20px; width: 100%; text-align: center; }
        .retry-btn { position: absolute; bottom: 20px; left: 20px; padding: 15px 30px; background: white; color: black; border-radius: 30px; font-weight: bold; pointer-events: auto; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div class="ui-layer">
        <div class="st-info">
            <h1 id="stName">STAGE 1</h1>
            <p>ボールを引っ張って離してください</p>
        </div>
        <div class="retry-btn" onclick="resetStage()">RETRY</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        let W, H;
        let ball = { x: 50, y: 50, r: 15, vx: 0, vy: 0, moving: false };
        let touch = { startX: 0, startY: 0, currX: 0, currY: 0, active: false };
        let currentStage = 0;

        const stages = [
            { holeX: 0.8, holeW: 80, groundY: 0.8 },
            { holeX: 0.7, holeW: 60, groundY: 0.8 },
            { holeX: 0.85, holeW: 50, groundY: 0.7 }
        ];

        function resize() {
            W = window.innerWidth;
            H = window.innerHeight;
            canvas.width = W;
            canvas.height = H;
            resetStage();
        }

        function resetStage() {
            const s = stages[currentStage] || stages[0];
            ball.x = 80;
            ball.y = (H * s.groundY) - ball.r - 20;
            ball.vx = 0;
            ball.vy = 0;
            ball.moving = false;
            document.getElementById('stName').innerText = `STAGE ${currentStage + 1}`;
        }

        // 入力
        window.addEventListener('touchstart', e => {
            if(!ball.moving) {
                touch.active = true;
                touch.startX = e.touches[0].clientX;
                touch.startY = e.touches[0].clientY;
                touch.currX = touch.startX;
                touch.currY = touch.startY;
            }
        }, {passive: false});

        window.addEventListener('touchmove', e => {
            if(touch.active) {
                touch.currX = e.touches[0].clientX;
                touch.currY = e.touches[0].clientY;
            }
            e.preventDefault();
        }, {passive: false});

        window.addEventListener('touchend', () => {
            if(touch.active) {
                ball.vx = (touch.startX - touch.currX) * 0.15;
                ball.vy = (touch.startY - touch.currY) * 0.15;
                ball.moving = true;
                touch.active = false;
            }
        });

        function loop() {
            // 背景
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, W, H);

            const s = stages[currentStage] || stages[0];
            const gY = H * s.groundY;
            const hL = (W * s.holeX) - (s.holeW / 2);

            // 地面
            ctx.fillStyle = '#10b981';
            ctx.fillRect(0, gY, W, H - gY);

            // 穴
            ctx.fillStyle = '#000000';
            ctx.fillRect(hL, gY, s.holeW, 50);

            // 物理
            if(ball.moving) {
                ball.vy += 0.5; // gravity
                ball.x += ball.vx;
                ball.y += ball.vy;

                // 地面・穴判定
                if(ball.y + ball.r > gY) {
                    if(ball.x > hL && ball.x < hL + s.holeW) {
                        // 入った
                        if(ball.y > gY + 20) {
                            currentStage = (currentStage + 1) % stages.length;
                            resetStage();
                        }
                    } else {
                        // バウンド
                        ball.y = gY - ball.r;
                        ball.vy *= -0.3;
                        ball.vx *= 0.8;
                    }
                }
            }

            // 予測線
            if(touch.active) {
                ctx.beginPath();
                ctx.strokeStyle = 'white';
                ctx.setLineDash([5, 5]);
                ctx.moveTo(ball.x, ball.y);
                ctx.lineTo(ball.x + (touch.startX - touch.currX), ball.y + (touch.startY - touch.currY));
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // ボールの描画 (最後に描く)
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
            ctx.fillStyle = 'white';
            ctx.fill();
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 3;
            ctx.stroke();

            // 画面外
            if(ball.y > H + 100 || ball.x < -100 || ball.x > W + 100) resetStage();

            requestAnimationFrame(loop);
        }

        window.addEventListener('resize', resize);
        resize();
        loop();
    </script>
</body>
</html>
