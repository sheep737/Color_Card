<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pull Golf Master 20 - ver 5.1.0</title>
    <style>
        * { -webkit-touch-callout: none; -webkit-user-select: none; user-select: none; }
        body { margin: 0; padding: 0; overflow: hidden; position: fixed; width: 100%; height: 100%; background: #000; font-family: sans-serif; }
        canvas { display: block; background: linear-gradient(#1a1a2e, #16213e); touch-action: none; }
        .ui { position: absolute; top: 40px; width: 100%; text-align: center; color: white; pointer-events: none; }
        .st-num { font-size: 0.8em; opacity: 0.7; }
        .btn { position: absolute; bottom: 30px; left: 20px; padding: 12px 24px; background: white; border: none; border-radius: 25px; font-weight: bold; pointer-events: auto; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div class="ui"><div class="st-num" id="stNum"></div><h2 id="stName"></h2><p id="stHint"></p></div>
    <button class="btn" onclick="resetStage()">リトライ</button>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gravity = 0.5;

        let width, height, currentStage = 0;
        let ball = { x: 100, y: 100, r: 12, vx: 0, vy: 0, moving: false, inHole: false };
        let touch = { start: null, curr: null };
        let gameTime = 0;
        const stages = [];

        function createStages() {
            stages.length = 0;
            for(let i=1; i<=20; i++) {
                let s = { name: `Level ${i}`, hint: "穴へ落とそう", holeX: 0.8, holeW: 70, groundY: 0.8, obs: [] };
                if(i===1) { s.obs.push({t:'block', x:0.4, y:0.5, w:20, h:200}); }
                else if(i===2) { s.obs.push({t:'rot', x:0.6, y:0.4, l:100, s:0.08}); }
                else if(i===3) { s.obs.push({t:'accel', x:0.4, y:0.78, w:80, p:15}); s.obs.push({t:'block', x:0.6, y:0.3, w:20, h:300}); }
                else if(i===4) { s.obs.push({t:'warp', x:0.3, y:0.6, tx:0.7, ty:0.2}); s.obs.push({t:'spike', x:0.4, y:0.78, w:150}); }
                else if(i===5) { s.obs.push({t:'move', x:0.3, y:0.6, w:100, h:20, r:150, s:3}); }
                else {
                    s.obs.push({t:'move', x:0.2, y:0.5, w:80, h:20, r:100, s:i*0.1});
                    if(i%2===0) s.obs.push({t:'warp', x:0.5, y:0.7, tx:0.8, ty:0.2});
                    s.obs.push({t:'spike', x:0.4, y:0.78, w:100});
                    s.holeW = Math.max(35, 70 - i);
                }
                stages.push(s);
            }
        }

        function resize() {
            width = window.innerWidth; height = window.innerHeight;
            canvas.width = width; canvas.height = height;
            createStages();
            resetStage();
        }

        function resetStage() {
            const s = stages[currentStage];
            // ボールの初期位置を地面の少し上に固定
            ball.x = 80;
            ball.y = (s.groundY * height) - ball.r - 10;
            ball.vx = 0;
            ball.vy = 0;
            ball.moving = false;
            ball.inHole = false;
            document.getElementById('stNum').innerText = `${currentStage+1}/20`;
            document.getElementById('stName').innerText = s.name;
            document.getElementById('stHint').innerText = s.hint || "";
        }

        canvas.addEventListener('touchstart', e => { 
            if(!ball.moving) { 
                touch.start = { x:e.touches[0].clientX, y:e.touches[0].clientY }; 
                touch.curr = touch.start; 
            } 
        }, {passive: false});
        canvas.addEventListener('touchmove', e => { 
            if(touch.start) touch.curr = { x:e.touches[0].clientX, y:e.touches[0].clientY }; 
        }, {passive: false});
        window.addEventListener('touchend', () => { 
            if(touch.start) { 
                ball.vx = (touch.start.x - touch.curr.x)*0.13; 
                ball.vy = (touch.start.y - touch.curr.y)*0.13; 
                ball.moving = true; 
            } 
            touch.start = null; 
        });

        function update() {
            gameTime++;
            const s = stages[currentStage];
            if(!ball.moving) return;

            ball.vy += gravity; ball.x += ball.vx; ball.y += ball.vy;
            const gY = s.groundY * height, hL = s.holeX * width - s.holeW/2, hR = s.holeX * width + s.holeW/2;

            s.obs.forEach(o => {
                if(o.t==='rot') {
                    o.a = (o.a || 0) + o.s;
                    let x2 = o.x*width + Math.cos(o.a)*o.l, y2 = o.y*height + Math.sin(o.a)*o.l;
                    let dx = x2-o.x*width, dy = y2-o.y*height, l2 = dx*dx+dy*dy;
                    let t = Math.max(0, Math.min(1, ((ball.x-o.x*width)*dx+(ball.y-o.y*height)*dy)/l2));
                    if(Math.hypot(ball.x-(o.x*width+t*dx), ball.y-(o.y*height+t*dy)) < ball.r) { ball.vx*=-1.2; ball.vy*=-1.2; }
                }
                if(o.t==='block' || o.t==='move') {
                    if(o.t==='move') { o.curX = (o.curX || o.x*width) + (o.dir || 1)*o.s; if(o.curX > o.x*width+o.r || o.curX < o.x*width) o.dir = (o.dir || 1)*-1; }
                    let bx = o.t==='move' ? o.curX : o.x*width, by = o.y*height, bw = o.w, bh = o.h;
                    if(ball.x+ball.r > bx && ball.x-ball.r < bx+bw && ball.y+ball.r > by && ball.y-ball.r < by+bh) {
                        ball.vx*=-0.7; ball.vy*=-0.7;
                    }
                }
                if(o.t==='accel' && ball.x > o.x*width && ball.x < o.x*width+o.w && Math.abs(ball.y+ball.r - gY) < 15) { ball.vx = o.p; }
                if(o.t==='warp' && Math.hypot(ball.x-o.x*width, ball.y-o.y*height) < 30) { ball.x = o.tx*width; ball.y = o.ty*height; }
                if(o.t==='spike' && ball.x > o.x*width && ball.x < o.x*width+o.w && ball.y+ball.r > gY-5 && !ball.inHole) resetStage();
            });

            if(ball.y + ball.r > gY) {
                if(ball.x > hL && ball.x < hR) { ball.inHole = true; ball.vx *= 0.9; }
                else if(!ball.inHole) { ball.y = gY-ball.r; ball.vy *= -0.3; ball.vx *= 0.8; }
            }
            if(ball.y > height + 50) { if(ball.inHole) { currentStage = (currentStage+1)%20; } resetStage(); }
            if(ball.x < -50 || ball.x > width+50) resetStage();
        }

        function draw() {
            ctx.clearRect(0, 0, width, height);
            const s = stages[currentStage];
            const gY = s.groundY*height, hX = s.holeX*width, hW = s.holeW;

            // 地面
            ctx.fillStyle = "#27ae60"; ctx.fillRect(0, gY, width, height-gY);
            // 穴
            ctx.fillStyle = "#1a1a2e"; ctx.fillRect(hX-hW/2, gY, hW, 100);

            s.obs.forEach(o => {
                if(o.t==='rot') { ctx.strokeStyle = "#f1c40f"; ctx.lineWidth = 8; ctx.beginPath(); ctx.moveTo(o.x*width, o.y*height); ctx.lineTo(o.x*width+Math.cos(o.a || 0)*o.l, o.y*height+Math.sin(o.a || 0)*o.l); ctx.stroke(); }
                if(o.t==='block') { ctx.fillStyle = "#95a5a6"; ctx.fillRect(o.x*width, o.y*height, o.w, o.h); }
                if(o.t==='move') { ctx.fillStyle = "#3498db"; ctx.fillRect(o.curX || o.x*width, o.y*height, o.w, o.h); }
                if(o.t==='accel') { ctx.fillStyle = "#e67e22"; ctx.fillRect(o.x*width, gY-5, o.w, 5); }
                if(o.t==='warp') { ctx.fillStyle = "#9b59b6"; ctx.beginPath(); ctx.arc(o.x*width, o.y*height, 15, 0, Math.PI*2); ctx.fill(); }
                if(o.t==='spike') { ctx.fillStyle = "#e74c3c"; for(let j=0; j<o.w; j+=15) { ctx.beginPath(); ctx.moveTo(o.x*width+j, gY); ctx.lineTo(o.x*width+j+7, gY-15); ctx.lineTo(o.x*width+j+15, gY); ctx.fill(); } }
            });

            // 予測線
            if (touch.start) {
                ctx.beginPath(); ctx.strokeStyle = "rgba(255,255,255,0.4)"; ctx.setLineDash([5,5]);
                let pv = {x:ball.x, y:ball.y, vx:(touch.start.x-touch.curr.x)*0.13, vy:(touch.start.y-touch.curr.y)*0.13};
                ctx.moveTo(pv.x, pv.y);
                for(let k=0; k<30; k++) { pv.vy+=gravity; pv.x+=pv.vx; pv.y+=pv.vy; ctx.lineTo(pv.x, pv.y); }
                ctx.stroke(); ctx.setLineDash([]);
            }

            // ボールを最後に描画（最前面）
            ctx.fillStyle = "white"; 
            ctx.beginPath(); 
            ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2); 
            ctx.fill();
            ctx.strokeStyle = "black"; 
            ctx.lineWidth = 2;
            ctx.stroke();

            update();
            requestAnimationFrame(draw);
        }

        window.addEventListener('resize', resize);
        resize();
    </script>
</body>
</html>
