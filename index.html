<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Pull Golf - ver 1.5.0</title>
    <style>
        body { text-align: center; background: #000; color: white; font-family: sans-serif; margin: 0; overflow: hidden; }
        canvas { background: #1e3c72; background: linear-gradient(to bottom, #1e3c72, #2a5298); touch-action: none; }
        .hud { position: absolute; top: 20px; width: 100%; pointer-events: none; }
        .v-tag { position: absolute; bottom: 10px; left: 10px; font-size: 12px; color: #555; }
        button { position: absolute; top: 20px; right: 20px; padding: 10px 20px; cursor: pointer; border-radius: 20px; border: none; background: #fff; font-weight: bold; box-shadow: 0 4px #ccc; }
        button:active { transform: translateY(2px); box-shadow: 0 2px #ccc; }
    </style>
</head>
<body>
    <div class="v-tag">ver 1.5.0 - Trajectory & Auto-In Update</div>
    <div class="hud">
        <h2 id="msg">Stage 1</h2>
        <div id="status">点線を穴に合わせて放そう！</div>
    </div>
    <button onclick="resetStage()">リトライ</button>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const gravity = 0.4;
        const groundY = canvas.height - 80;
        let currentStage = 0;
        
        let ball = { x: 100, y: groundY - 15, r: 12, vx: 0, vy: 0, moving: false };
        let anchor = null;
        let dragPos = null;

        const stages = [
            { name: "まずは真っ直ぐ狙おう", hole: {x: canvas.width - 200, y: groundY}, walls: [] },
            { name: "壁を飛び越えて", hole: {x: canvas.width - 150, y: groundY}, walls: [{x: canvas.width/2, y: groundY-120, w: 40, h: 120}] },
            { name: "リフトで運ぶ", hole: {x: canvas.width - 150, y: groundY - 250}, 
              walls: [{x: 400, y: groundY-50, w: 150, h: 20, type: 'lift', range: 200, speed: 0.02, base: groundY-50},
                      {x: canvas.width - 300, y: groundY-250, w: 300, h: 20}] }
        ];

        function onStart(x, y) { if (!ball.moving) { anchor = { x, y }; dragPos = { x, y }; } }
        function onMove(x, y) { if (anchor) dragPos = { x, y }; }
        function onEnd() {
            if (anchor && dragPos) {
                ball.vx = (anchor.x - dragPos.x) * 0.12;
                ball.vy = (anchor.y - dragPos.y) * 0.12;
                ball.moving = true;
            }
            anchor = null; dragPos = null;
        }

        canvas.addEventListener('mousedown', e => onStart(e.clientX, e.clientY));
        window.addEventListener('mousemove', e => onMove(e.clientX, e.clientY));
        window.addEventListener('mouseup', onEnd);
        canvas.addEventListener('touchstart', e => { e.preventDefault(); onStart(e.touches[0].clientX, e.touches[0].clientY); });
        canvas.addEventListener('touchmove', e => { e.preventDefault(); onMove(e.touches[0].clientX, e.touches[0].clientY); });
        window.addEventListener('touchend', onEnd);

        function update() {
            const s = stages[currentStage];
            s.walls.forEach(w => { if (w.type === 'lift') w.y = w.base + Math.sin(Date.now() * w.speed) * w.range; });

            if (ball.moving) {
                ball.vy += gravity;
                ball.x += ball.vx;
                ball.y += ball.vy;

                // 穴への吸い込み（ホーミング）
                const distToHole = Math.hypot(ball.x - s.hole.x, ball.y - s.hole.y);
                if (distToHole < 50) {
                    ball.vx += (s.hole.x - ball.x) * 0.05;
                    ball.vy += (s.hole.y - ball.y) * 0.05;
                }

                if (ball.y + ball.r > groundY) {
                    ball.y = groundY - ball.r;
                    ball.vy *= -0.3; ball.vx *= 0.95;
                }

                s.walls.forEach(w => {
                    if (ball.x + ball.r > w.x && ball.x - ball.r < w.x + w.w && ball.y + ball.r > w.y && ball.y - ball.r < w.y + w.h) {
                        if (ball.y < w.y + 15) { ball.y = w.y - ball.r; ball.vy *= -0.2; ball.vx *= 0.9; }
                        else { ball.vx *= -0.5; }
                    }
                });

                if (Math.abs(ball.vx) < 0.2 && Math.abs(ball.vy) < 0.5) {
                    ball.moving = false;
                    if (distToHole < 25) nextStage();
                }
            }
            if (ball.y > canvas.height || ball.x < 0 || ball.x > canvas.width) resetStage();
        }

        function nextStage() {
            alert("Nice In!");
            currentStage = (currentStage + 1) % stages.length;
            resetStage();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const s = stages[currentStage];
            document.getElementById('msg').innerText = s.name;

            // 穴
            ctx.fillStyle = "#111";
            ctx.beginPath(); ctx.arc(s.hole.x, s.hole.y, 20, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = "#fff"; ctx.stroke();

            // 地面と壁
            ctx.fillStyle = "#27ae60"; ctx.fillRect(0, groundY, canvas.width, 80);
            ctx.fillStyle = "#ecf0f1"; s.walls.forEach(w => ctx.fillRect(w.x, w.y, w.w, w.h));

            // 予測線（放物線）
            if (anchor && dragPos) {
                let pv = { x: ball.x, y: ball.y, vx: (anchor.x - dragPos.x) * 0.12, vy: (anchor.y - dragPos.y) * 0.12 };
                ctx.beginPath();
                ctx.setLineDash([5, 5]);
                ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
                ctx.moveTo(pv.x, pv.y);
                for (let i = 0; i < 30; i++) {
                    pv.vy += gravity; pv.x += pv.vx; pv.y += pv.vy;
                    ctx.lineTo(pv.x, pv.y);
                }
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // ボール
            ctx.fillStyle = "#fff";
            ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2); ctx.fill();

            update();
            requestAnimationFrame(draw);
        }

        function resetStage() {
            ball.x = 100; ball.y = groundY - 15; ball.vx = 0; ball.vy = 0; ball.moving = false;
            anchor = null; dragPos = null;
        }

        draw();
    </script>
</body>
</html>
